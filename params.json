{"body":"Node Core Audio\r\n==================\r\nThis is a C++ extension for node.js that gives javascript access to audio buffers and basic audio processing functionality\r\n\r\nRight now, it's basically a node.js binding for PortAudio.\r\n\r\nInstallation\r\n=====\r\n```\r\nnpm install node-core-audio\r\n```\r\n\r\nDisclaimer\r\n=====\r\nThis extension is still under heavy development, and should be considered \r\npre-alpha. I wouldn't suggest you even try to use it, unless you're willing to roll up your\r\nsleeves from time to time.\r\n\r\nI am actively working on this, but if you want to see it happen faster, please \r\nsend me an email!\r\n\r\nBasic Usage\r\n=====\r\nThis package is setup as a \"pull\" system, meaning that the audio engine will \r\ncall your processing function when it's ready to get new samples, as opposed\r\nto a \"push\" system, where you post audio to the sound card.\r\n\r\nBelow is the most basic use of the audio engine. We create a new instance of\r\nnode-core-audio, and then give it our processing function. The audio engine\r\nwill call the audio callback whenever it needs an output buffer to send to\r\nthe sound card.\r\n```javascript\r\n// Create a new instance of node-core-audio\r\nvar coreAudio = require(\"node-core-audio\").createNewAudioEngine();\r\n\r\n// Add an audio processing callback\r\n// Note: This function MUST return a buffer to the audio engine! If \r\n// not, your application will throw an exception.\r\ncoreAudio.addAudioCallback( function( numSamples, inputBuffer ) {\r\n\tconsole.log( \"sweet\" );\r\n\treturn inputBuffer;\r\n});\r\n```\r\n\r\nImportant! Processing Thread\r\n=====\r\nWhen you are writing code inside of your audio callback, you are operating on\r\nthe processing thread of the application. Any large allocations will cause the\r\nprogram to crash, and you will get no error whatsoever. This is a bug, and I\r\nhope to fix it soon.\r\n\r\nDO NOT DO THESE INSIDE THE AUDIO CALLBACK (or anything like them):\r\n```javascript\r\nvar array = [];\r\nvar array = new Array();\t\t// Allocating for arrays is not okay\r\nvar object = {};\t\t\t\t// Allocating for objects is not okay\r\nvar callback = function(){};\t// Allocating for functions is not okay\r\nsocket.emit(...);\t\t\t\t// Doing socket stuff is not okay (because it causes object/array allocations)\r\n```\r\n\r\nThe basic principle is that you should have everything ready to go before you enter\r\nthe processing function. Buffers, objects, and functions should be created in a \r\nconstructor or static function outside of the audio callback.\r\n\r\nSimple allocations and assignments are okay (you CAN do these):\r\n```javascript\r\n// Simple allocation\r\nvar someValue = 10;\t\r\n\r\n// Assignment of whole buffers\r\npreAllocatedBuffer = inputBuffer;\r\n\r\n// Sample by sample processing\r\nfor( var iSample = 0; iSample < numSamples; ++iSample ) {\r\n\tpreAllocatedBuffer[iSample] = numSamples / iSample;\r\n}\r\n```\r\n\r\nAudio Engine Options (not implimented as of version 0.0.5)\r\n=====\r\n* Sample rate - number of samples per second in the audio stream\r\n* Bit depth - Number of bits used to represent sample values\r\n* Buffer length - Number of samples per buffer\r\n* Interlaced / Deinterlaced - determines whether samples are given to you as a two dimensional array (buffer[channel][sample]) or one buffer with samples from alternating channels\r\n\r\nAPI (much more to come!)\r\n=====\r\n```javascript\r\nvar coreAudio = require(\"node-core-audio\").createNewAudioEngine();\r\n\r\n// Adds an audio callback to the audio engine (MUST RETURN AN OUTPUT BUFFER)\r\ncoreAudio.addAudioCallback( function(numSamples, inputBuffer){ return inputBuffer; } );\r\n\r\n// Returns whether the audio engine is active\r\nvar isActive = coreAudio.isActive();\r\n\r\n// Returns the sample rate of the audio engine\r\nvar sampleRate = coreAudio.getSampleRate();\r\n\r\n// Returns the index of the input audio device \r\nvar inputDeviceIndex = coreAudio.getInputDeviceIndex();\r\n\r\n// Returns the index of the output audio device \r\nvar outputDeviceIndex = coreAudio.getOutputDeviceIndex();\r\n\r\n// Returns the name of a given device \r\nvar inputDeviceName = coreAudio.getDeviceName( inputDeviceIndex );\r\n\r\n// Returns the total number of audio devices\r\nvar numDevices = coreAudio.getNumDevices();\r\n\r\n// Sets the input audio device\r\ncoreAudio.setInputDevice( someDeviceId );\r\n\r\n// Sets the output audio device\r\ncoreAudio.setOutputDevice( someDeviceId );\r\n```\r\n\r\nKnown Issues / TODO\r\n=====\r\nI know, I know, I'm sorry. I'll fix them, don't worry.\r\n\r\n* Create thread for Javascript/UI - allocations from javascript shouldn't cause crashes\r\n* Add FFTW to C++ extension, so you can get fast FFT's from javascript, and also register for the FFT of incoming audio, rather than the audio itself\r\n* Add support for streaming audio over sockets\r\n\r\nLicense - MIT\r\n=====\r\nCopyright (c) 2012, Mike Vegeto (michael.vegeto@gmail.com)\r\nAll rights reserved.\r\n\r\nSee LICENSE file","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Node-core-audio","tagline":"Core audio processing funcionality for node.js","google":"UA-34227536-1"}